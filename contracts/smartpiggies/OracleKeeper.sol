// SPDX-License-Identifier: MIT
/**
 *  Submission for EthDenver 20222 Live hacking participation Event
 *  Implement a chainlink keeper design pattern into the SmartPiggies
 *  bi-lateral risk transfer instrument platform.
 *
 *  This Oracle Proxy will by a resolver when a new piggy is created.
 *  The proxy will keep track of all requested callbacks,
 *  during the checkUpkeep phase, requests with met expiry conditions
 *  will be forwarded to the performUpkeep phase to retrieve a price
 *  and return the price back to the SmartPiggies contract.
 */
pragma solidity ^0.8.7;

//import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract OracleKeeper {

    address public owner;
    AggregatorV3Interface internal priceFeed;

    constructor() {
      priceFeed = AggregatorV3Interface(0x0715A7794a1dc8e42615F059dD6e406A6594651A); // ETH/USD
      owner = msg.sender;
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
    (
      uint80 roundID,
      int price,
      uint startedAt,
      uint timeStamp,
      uint80 answeredInRound
    ) = priceFeed.latestRoundData();
      return price;
    }

    function checkUpkeep(bytes calldata /* checkData */)
      external
      returns (bool upkeepNeeded, bytes memory /* performData */)
    {
      // performed off-chain to determine if performUpkeep is to be executed
      // We don't use the checkData in this example.
      // The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external {
      // We highly recommend revalidating the upkeep in the performUpkeep function
      // We don't use the performData in this example.
      // The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function registerDataCall()
      public
      returns (bool)
    {
      return true;
    }

    function catchDataCall()
      public
      returns (bool)
    {
      return true;
    }

    function kill()
      public
    {
      require(msg.sender == owner);
      selfdestruct(payable(owner));
    }
}
